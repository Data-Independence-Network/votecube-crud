// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/null"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// UserAccount is an object representing the database table.
type UserAccount struct {
	UserAccountID        int64       `boil:"user_account_id" json:"user_account_id" toml:"user_account_id" yaml:"user_account_id"`
	UserName             string      `boil:"user_name" json:"user_name" toml:"user_name" yaml:"user_name"`
	FirstName            null.String `boil:"first_name" json:"first_name,omitempty" toml:"first_name" yaml:"first_name,omitempty"`
	MiddleNameOrInitials null.String `boil:"middle_name_or_initials" json:"middle_name_or_initials,omitempty" toml:"middle_name_or_initials" yaml:"middle_name_or_initials,omitempty"`
	PrefixLastNameID     int64       `boil:"prefix_last_name_id" json:"prefix_last_name_id" toml:"prefix_last_name_id" yaml:"prefix_last_name_id"`
	LastName             null.String `boil:"last_name" json:"last_name,omitempty" toml:"last_name" yaml:"last_name,omitempty"`
	NameAfterLastNameID  int64       `boil:"name_after_last_name_id" json:"name_after_last_name_id" toml:"name_after_last_name_id" yaml:"name_after_last_name_id"`
	BirthDate            time.Time   `boil:"birth_date" json:"birth_date" toml:"birth_date" yaml:"birth_date"`
	CreatedAt            time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *userAccountR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L userAccountL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var UserAccountColumns = struct {
	UserAccountID        string
	UserName             string
	FirstName            string
	MiddleNameOrInitials string
	PrefixLastNameID     string
	LastName             string
	NameAfterLastNameID  string
	BirthDate            string
	CreatedAt            string
}{
	UserAccountID:        "user_account_id",
	UserName:             "user_name",
	FirstName:            "first_name",
	MiddleNameOrInitials: "middle_name_or_initials",
	PrefixLastNameID:     "prefix_last_name_id",
	LastName:             "last_name",
	NameAfterLastNameID:  "name_after_last_name_id",
	BirthDate:            "birth_date",
	CreatedAt:            "created_at",
}

// UserAccountRels is where relationship names are stored.
var UserAccountRels = struct {
	PrefixLastName         string
	NameAfterLastName      string
	Dimensions             string
	DimensionsLinks        string
	Directions             string
	EmailAddresses         string
	EmailDomains           string
	Labels                 string
	Links                  string
	Messages               string
	Polls                  string
	PollsGroups            string
	PollsLabels            string
	PollsLinks             string
	PollsPollsGroups       string
	UserAccountEthnicities string
	UserAccountSuffixes    string
	UserPersonalInfos      string
	Votes                  string
}{
	PrefixLastName:         "PrefixLastName",
	NameAfterLastName:      "NameAfterLastName",
	Dimensions:             "Dimensions",
	DimensionsLinks:        "DimensionsLinks",
	Directions:             "Directions",
	EmailAddresses:         "EmailAddresses",
	EmailDomains:           "EmailDomains",
	Labels:                 "Labels",
	Links:                  "Links",
	Messages:               "Messages",
	Polls:                  "Polls",
	PollsGroups:            "PollsGroups",
	PollsLabels:            "PollsLabels",
	PollsLinks:             "PollsLinks",
	PollsPollsGroups:       "PollsPollsGroups",
	UserAccountEthnicities: "UserAccountEthnicities",
	UserAccountSuffixes:    "UserAccountSuffixes",
	UserPersonalInfos:      "UserPersonalInfos",
	Votes:                  "Votes",
}

// userAccountR is where relationships are stored.
type userAccountR struct {
	PrefixLastName         *PrefixLastName
	NameAfterLastName      *NameAfterLastName
	Dimensions             DimensionSlice
	DimensionsLinks        DimensionsLinkSlice
	Directions             DirectionSlice
	EmailAddresses         EmailAddressSlice
	EmailDomains           EmailDomainSlice
	Labels                 LabelSlice
	Links                  LinkSlice
	Messages               MessageSlice
	Polls                  PollSlice
	PollsGroups            PollsGroupSlice
	PollsLabels            PollsLabelSlice
	PollsLinks             PollsLinkSlice
	PollsPollsGroups       PollsPollsGroupSlice
	UserAccountEthnicities UserAccountEthnicitySlice
	UserAccountSuffixes    UserAccountSuffixSlice
	UserPersonalInfos      UserPersonalInfoSlice
	Votes                  VoteSlice
}

// NewStruct creates a new relationship struct
func (*userAccountR) NewStruct() *userAccountR {
	return &userAccountR{}
}

// userAccountL is where Load methods for each relationship are stored.
type userAccountL struct{}

var (
	userAccountColumns               = []string{"user_account_id", "user_name", "first_name", "middle_name_or_initials", "prefix_last_name_id", "last_name", "name_after_last_name_id", "birth_date", "created_at"}
	userAccountColumnsWithoutDefault = []string{"user_account_id", "user_name", "first_name", "middle_name_or_initials", "prefix_last_name_id", "last_name", "name_after_last_name_id", "birth_date"}
	userAccountColumnsWithDefault    = []string{"created_at"}
	userAccountPrimaryKeyColumns     = []string{"user_account_id"}
)

type (
	// UserAccountSlice is an alias for a slice of pointers to UserAccount.
	// This should generally be used opposed to []UserAccount.
	UserAccountSlice []*UserAccount
	// UserAccountHook is the signature for custom UserAccount hook methods
	UserAccountHook func(context.Context, boil.ContextExecutor, *UserAccount) error

	userAccountQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	userAccountType                 = reflect.TypeOf(&UserAccount{})
	userAccountMapping              = queries.MakeStructMapping(userAccountType)
	userAccountPrimaryKeyMapping, _ = queries.BindMapping(userAccountType, userAccountMapping, userAccountPrimaryKeyColumns)
	userAccountInsertCacheMut       sync.RWMutex
	userAccountInsertCache          = make(map[string]insertCache)
	userAccountUpdateCacheMut       sync.RWMutex
	userAccountUpdateCache          = make(map[string]updateCache)
	userAccountUpsertCacheMut       sync.RWMutex
	userAccountUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
)

var userAccountBeforeInsertHooks []UserAccountHook
var userAccountBeforeUpdateHooks []UserAccountHook
var userAccountBeforeDeleteHooks []UserAccountHook
var userAccountBeforeUpsertHooks []UserAccountHook

var userAccountAfterInsertHooks []UserAccountHook
var userAccountAfterSelectHooks []UserAccountHook
var userAccountAfterUpdateHooks []UserAccountHook
var userAccountAfterDeleteHooks []UserAccountHook
var userAccountAfterUpsertHooks []UserAccountHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *UserAccount) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *UserAccount) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *UserAccount) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *UserAccount) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *UserAccount) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *UserAccount) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *UserAccount) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *UserAccount) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *UserAccount) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range userAccountAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddUserAccountHook registers your hook function for all future operations.
func AddUserAccountHook(hookPoint boil.HookPoint, userAccountHook UserAccountHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		userAccountBeforeInsertHooks = append(userAccountBeforeInsertHooks, userAccountHook)
	case boil.BeforeUpdateHook:
		userAccountBeforeUpdateHooks = append(userAccountBeforeUpdateHooks, userAccountHook)
	case boil.BeforeDeleteHook:
		userAccountBeforeDeleteHooks = append(userAccountBeforeDeleteHooks, userAccountHook)
	case boil.BeforeUpsertHook:
		userAccountBeforeUpsertHooks = append(userAccountBeforeUpsertHooks, userAccountHook)
	case boil.AfterInsertHook:
		userAccountAfterInsertHooks = append(userAccountAfterInsertHooks, userAccountHook)
	case boil.AfterSelectHook:
		userAccountAfterSelectHooks = append(userAccountAfterSelectHooks, userAccountHook)
	case boil.AfterUpdateHook:
		userAccountAfterUpdateHooks = append(userAccountAfterUpdateHooks, userAccountHook)
	case boil.AfterDeleteHook:
		userAccountAfterDeleteHooks = append(userAccountAfterDeleteHooks, userAccountHook)
	case boil.AfterUpsertHook:
		userAccountAfterUpsertHooks = append(userAccountAfterUpsertHooks, userAccountHook)
	}
}

// OneG returns a single userAccount record from the query using the global executor.
func (q userAccountQuery) OneG(ctx context.Context) (*UserAccount, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single userAccount record from the query.
func (q userAccountQuery) One(ctx context.Context, exec boil.ContextExecutor) (*UserAccount, error) {
	o := &UserAccount{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for user_account")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all UserAccount records from the query using the global executor.
func (q userAccountQuery) AllG(ctx context.Context) (UserAccountSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all UserAccount records from the query.
func (q userAccountQuery) All(ctx context.Context, exec boil.ContextExecutor) (UserAccountSlice, error) {
	var o []*UserAccount

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to UserAccount slice")
	}

	if len(userAccountAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all UserAccount records in the query, and panics on error.
func (q userAccountQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all UserAccount records in the query.
func (q userAccountQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count user_account rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table, and panics on error.
func (q userAccountQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q userAccountQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if user_account exists")
	}

	return count > 0, nil
}

// PrefixLastName pointed to by the foreign key.
func (o *UserAccount) PrefixLastName(mods ...qm.QueryMod) prefixLastNameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("prefix_last_name_id=?", o.PrefixLastNameID),
	}

	queryMods = append(queryMods, mods...)

	query := PrefixLastNames(queryMods...)
	queries.SetFrom(query.Query, "\"prefix_last_name\"")

	return query
}

// NameAfterLastName pointed to by the foreign key.
func (o *UserAccount) NameAfterLastName(mods ...qm.QueryMod) nameAfterLastNameQuery {
	queryMods := []qm.QueryMod{
		qm.Where("name_after_last_name_id=?", o.NameAfterLastNameID),
	}

	queryMods = append(queryMods, mods...)

	query := NameAfterLastNames(queryMods...)
	queries.SetFrom(query.Query, "\"name_after_last_name\"")

	return query
}

// Dimensions retrieves all the dimension's Dimensions with an executor.
func (o *UserAccount) Dimensions(mods ...qm.QueryMod) dimensionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"dimensions\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Dimensions(queryMods...)
	queries.SetFrom(query.Query, "\"dimensions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"dimensions\".*"})
	}

	return query
}

// DimensionsLinks retrieves all the dimensions_link's DimensionsLinks with an executor.
func (o *UserAccount) DimensionsLinks(mods ...qm.QueryMod) dimensionsLinkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"dimensions_links\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := DimensionsLinks(queryMods...)
	queries.SetFrom(query.Query, "\"dimensions_links\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"dimensions_links\".*"})
	}

	return query
}

// Directions retrieves all the direction's Directions with an executor.
func (o *UserAccount) Directions(mods ...qm.QueryMod) directionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"directions\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Directions(queryMods...)
	queries.SetFrom(query.Query, "\"directions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"directions\".*"})
	}

	return query
}

// EmailAddresses retrieves all the email_address's EmailAddresses with an executor.
func (o *UserAccount) EmailAddresses(mods ...qm.QueryMod) emailAddressQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"email_address\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := EmailAddresses(queryMods...)
	queries.SetFrom(query.Query, "\"email_address\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"email_address\".*"})
	}

	return query
}

// EmailDomains retrieves all the email_domain's EmailDomains with an executor.
func (o *UserAccount) EmailDomains(mods ...qm.QueryMod) emailDomainQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"email_domain\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := EmailDomains(queryMods...)
	queries.SetFrom(query.Query, "\"email_domain\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"email_domain\".*"})
	}

	return query
}

// Labels retrieves all the label's Labels with an executor.
func (o *UserAccount) Labels(mods ...qm.QueryMod) labelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"labels\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Labels(queryMods...)
	queries.SetFrom(query.Query, "\"labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"labels\".*"})
	}

	return query
}

// Links retrieves all the link's Links with an executor.
func (o *UserAccount) Links(mods ...qm.QueryMod) linkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"links\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Links(queryMods...)
	queries.SetFrom(query.Query, "\"links\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"links\".*"})
	}

	return query
}

// Messages retrieves all the message's Messages with an executor.
func (o *UserAccount) Messages(mods ...qm.QueryMod) messageQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"messages\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Messages(queryMods...)
	queries.SetFrom(query.Query, "\"messages\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"messages\".*"})
	}

	return query
}

// Polls retrieves all the poll's Polls with an executor.
func (o *UserAccount) Polls(mods ...qm.QueryMod) pollQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Polls(queryMods...)
	queries.SetFrom(query.Query, "\"polls\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls\".*"})
	}

	return query
}

// PollsGroups retrieves all the polls_group's PollsGroups with an executor.
func (o *UserAccount) PollsGroups(mods ...qm.QueryMod) pollsGroupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls_groups\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := PollsGroups(queryMods...)
	queries.SetFrom(query.Query, "\"polls_groups\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls_groups\".*"})
	}

	return query
}

// PollsLabels retrieves all the polls_label's PollsLabels with an executor.
func (o *UserAccount) PollsLabels(mods ...qm.QueryMod) pollsLabelQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls_labels\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := PollsLabels(queryMods...)
	queries.SetFrom(query.Query, "\"polls_labels\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls_labels\".*"})
	}

	return query
}

// PollsLinks retrieves all the polls_link's PollsLinks with an executor.
func (o *UserAccount) PollsLinks(mods ...qm.QueryMod) pollsLinkQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls_links\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := PollsLinks(queryMods...)
	queries.SetFrom(query.Query, "\"polls_links\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls_links\".*"})
	}

	return query
}

// PollsPollsGroups retrieves all the polls_polls_group's PollsPollsGroups with an executor.
func (o *UserAccount) PollsPollsGroups(mods ...qm.QueryMod) pollsPollsGroupQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls_polls_groups\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := PollsPollsGroups(queryMods...)
	queries.SetFrom(query.Query, "\"polls_polls_groups\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls_polls_groups\".*"})
	}

	return query
}

// UserAccountEthnicities retrieves all the user_account_ethnicity's UserAccountEthnicities with an executor.
func (o *UserAccount) UserAccountEthnicities(mods ...qm.QueryMod) userAccountEthnicityQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_account_ethnicity\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := UserAccountEthnicities(queryMods...)
	queries.SetFrom(query.Query, "\"user_account_ethnicity\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_account_ethnicity\".*"})
	}

	return query
}

// UserAccountSuffixes retrieves all the user_account_suffix's UserAccountSuffixes with an executor.
func (o *UserAccount) UserAccountSuffixes(mods ...qm.QueryMod) userAccountSuffixQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_account_suffix\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := UserAccountSuffixes(queryMods...)
	queries.SetFrom(query.Query, "\"user_account_suffix\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_account_suffix\".*"})
	}

	return query
}

// UserPersonalInfos retrieves all the user_personal_info's UserPersonalInfos with an executor.
func (o *UserAccount) UserPersonalInfos(mods ...qm.QueryMod) userPersonalInfoQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"user_personal_info\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := UserPersonalInfos(queryMods...)
	queries.SetFrom(query.Query, "\"user_personal_info\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"user_personal_info\".*"})
	}

	return query
}

// Votes retrieves all the vote's Votes with an executor.
func (o *UserAccount) Votes(mods ...qm.QueryMod) voteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"vote\".\"user_account_id\"=?", o.UserAccountID),
	)

	query := Votes(queryMods...)
	queries.SetFrom(query.Query, "\"vote\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"vote\".*"})
	}

	return query
}

// LoadPrefixLastName allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userAccountL) LoadPrefixLastName(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.PrefixLastNameID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.PrefixLastNameID {
					continue Outer
				}
			}

			args = append(args, obj.PrefixLastNameID)
		}
	}

	query := NewQuery(qm.From(`prefix_last_name`), qm.WhereIn(`prefix_last_name_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load PrefixLastName")
	}

	var resultSlice []*PrefixLastName
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice PrefixLastName")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for prefix_last_name")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for prefix_last_name")
	}

	if len(userAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.PrefixLastName = foreign
		if foreign.R == nil {
			foreign.R = &prefixLastNameR{}
		}
		foreign.R.UserAccounts = append(foreign.R.UserAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PrefixLastNameID == foreign.PrefixLastNameID {
				local.R.PrefixLastName = foreign
				if foreign.R == nil {
					foreign.R = &prefixLastNameR{}
				}
				foreign.R.UserAccounts = append(foreign.R.UserAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadNameAfterLastName allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (userAccountL) LoadNameAfterLastName(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.NameAfterLastNameID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.NameAfterLastNameID {
					continue Outer
				}
			}

			args = append(args, obj.NameAfterLastNameID)
		}
	}

	query := NewQuery(qm.From(`name_after_last_name`), qm.WhereIn(`name_after_last_name_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load NameAfterLastName")
	}

	var resultSlice []*NameAfterLastName
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice NameAfterLastName")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for name_after_last_name")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for name_after_last_name")
	}

	if len(userAccountAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.NameAfterLastName = foreign
		if foreign.R == nil {
			foreign.R = &nameAfterLastNameR{}
		}
		foreign.R.UserAccounts = append(foreign.R.UserAccounts, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.NameAfterLastNameID == foreign.NameAfterLastNameID {
				local.R.NameAfterLastName = foreign
				if foreign.R == nil {
					foreign.R = &nameAfterLastNameR{}
				}
				foreign.R.UserAccounts = append(foreign.R.UserAccounts, local)
				break
			}
		}
	}

	return nil
}

// LoadDimensions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadDimensions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`dimensions`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dimensions")
	}

	var resultSlice []*Dimension
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dimensions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dimensions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dimensions")
	}

	if len(dimensionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Dimensions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dimensionR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Dimensions = append(local.R.Dimensions, foreign)
				if foreign.R == nil {
					foreign.R = &dimensionR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadDimensionsLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadDimensionsLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`dimensions_links`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load dimensions_links")
	}

	var resultSlice []*DimensionsLink
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice dimensions_links")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on dimensions_links")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for dimensions_links")
	}

	if len(dimensionsLinkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.DimensionsLinks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &dimensionsLinkR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.DimensionsLinks = append(local.R.DimensionsLinks, foreign)
				if foreign.R == nil {
					foreign.R = &dimensionsLinkR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadDirections allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadDirections(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`directions`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load directions")
	}

	var resultSlice []*Direction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice directions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on directions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for directions")
	}

	if len(directionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Directions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &directionR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Directions = append(local.R.Directions, foreign)
				if foreign.R == nil {
					foreign.R = &directionR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadEmailAddresses allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadEmailAddresses(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`email_address`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load email_address")
	}

	var resultSlice []*EmailAddress
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice email_address")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on email_address")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for email_address")
	}

	if len(emailAddressAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EmailAddresses = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emailAddressR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.EmailAddresses = append(local.R.EmailAddresses, foreign)
				if foreign.R == nil {
					foreign.R = &emailAddressR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadEmailDomains allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadEmailDomains(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`email_domain`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load email_domain")
	}

	var resultSlice []*EmailDomain
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice email_domain")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on email_domain")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for email_domain")
	}

	if len(emailDomainAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.EmailDomains = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &emailDomainR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.EmailDomains = append(local.R.EmailDomains, foreign)
				if foreign.R == nil {
					foreign.R = &emailDomainR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`labels`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load labels")
	}

	var resultSlice []*Label
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for labels")
	}

	if len(labelAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Labels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &labelR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Labels = append(local.R.Labels, foreign)
				if foreign.R == nil {
					foreign.R = &labelR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`links`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load links")
	}

	var resultSlice []*Link
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice links")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on links")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for links")
	}

	if len(linkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Links = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &linkR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Links = append(local.R.Links, foreign)
				if foreign.R == nil {
					foreign.R = &linkR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadMessages allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadMessages(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`messages`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load messages")
	}

	var resultSlice []*Message
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice messages")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on messages")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for messages")
	}

	if len(messageAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Messages = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &messageR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Messages = append(local.R.Messages, foreign)
				if foreign.R == nil {
					foreign.R = &messageR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPolls allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadPolls(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`polls`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls")
	}

	var resultSlice []*Poll
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls")
	}

	if len(pollAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Polls = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Polls = append(local.R.Polls, foreign)
				if foreign.R == nil {
					foreign.R = &pollR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPollsGroups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadPollsGroups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`polls_groups`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls_groups")
	}

	var resultSlice []*PollsGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls_groups")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls_groups")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls_groups")
	}

	if len(pollsGroupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PollsGroups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollsGroupR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.PollsGroups = append(local.R.PollsGroups, foreign)
				if foreign.R == nil {
					foreign.R = &pollsGroupR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPollsLabels allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadPollsLabels(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`polls_labels`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls_labels")
	}

	var resultSlice []*PollsLabel
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls_labels")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls_labels")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls_labels")
	}

	if len(pollsLabelAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PollsLabels = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollsLabelR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.PollsLabels = append(local.R.PollsLabels, foreign)
				if foreign.R == nil {
					foreign.R = &pollsLabelR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPollsLinks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadPollsLinks(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`polls_links`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls_links")
	}

	var resultSlice []*PollsLink
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls_links")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls_links")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls_links")
	}

	if len(pollsLinkAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PollsLinks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollsLinkR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.PollsLinks = append(local.R.PollsLinks, foreign)
				if foreign.R == nil {
					foreign.R = &pollsLinkR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadPollsPollsGroups allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadPollsPollsGroups(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`polls_polls_groups`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls_polls_groups")
	}

	var resultSlice []*PollsPollsGroup
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls_polls_groups")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls_polls_groups")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls_polls_groups")
	}

	if len(pollsPollsGroupAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PollsPollsGroups = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollsPollsGroupR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.PollsPollsGroups = append(local.R.PollsPollsGroups, foreign)
				if foreign.R == nil {
					foreign.R = &pollsPollsGroupR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadUserAccountEthnicities allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadUserAccountEthnicities(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`user_account_ethnicity`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_account_ethnicity")
	}

	var resultSlice []*UserAccountEthnicity
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_account_ethnicity")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_account_ethnicity")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_account_ethnicity")
	}

	if len(userAccountEthnicityAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAccountEthnicities = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAccountEthnicityR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.UserAccountEthnicities = append(local.R.UserAccountEthnicities, foreign)
				if foreign.R == nil {
					foreign.R = &userAccountEthnicityR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadUserAccountSuffixes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadUserAccountSuffixes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`user_account_suffix`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_account_suffix")
	}

	var resultSlice []*UserAccountSuffix
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_account_suffix")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_account_suffix")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_account_suffix")
	}

	if len(userAccountSuffixAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserAccountSuffixes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userAccountSuffixR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.UserAccountSuffixes = append(local.R.UserAccountSuffixes, foreign)
				if foreign.R == nil {
					foreign.R = &userAccountSuffixR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadUserPersonalInfos allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadUserPersonalInfos(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`user_personal_info`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load user_personal_info")
	}

	var resultSlice []*UserPersonalInfo
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice user_personal_info")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on user_personal_info")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for user_personal_info")
	}

	if len(userPersonalInfoAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.UserPersonalInfos = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &userPersonalInfoR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.UserPersonalInfos = append(local.R.UserPersonalInfos, foreign)
				if foreign.R == nil {
					foreign.R = &userPersonalInfoR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// LoadVotes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (userAccountL) LoadVotes(ctx context.Context, e boil.ContextExecutor, singular bool, maybeUserAccount interface{}, mods queries.Applicator) error {
	var slice []*UserAccount
	var object *UserAccount

	if singular {
		object = maybeUserAccount.(*UserAccount)
	} else {
		slice = *maybeUserAccount.(*[]*UserAccount)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &userAccountR{}
		}
		args = append(args, object.UserAccountID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &userAccountR{}
			}

			for _, a := range args {
				if a == obj.UserAccountID {
					continue Outer
				}
			}

			args = append(args, obj.UserAccountID)
		}
	}

	query := NewQuery(qm.From(`vote`), qm.WhereIn(`user_account_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load vote")
	}

	var resultSlice []*Vote
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice vote")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on vote")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for vote")
	}

	if len(voteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Votes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &voteR{}
			}
			foreign.R.UserAccount = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.UserAccountID == foreign.UserAccountID {
				local.R.Votes = append(local.R.Votes, foreign)
				if foreign.R == nil {
					foreign.R = &voteR{}
				}
				foreign.R.UserAccount = local
				break
			}
		}
	}

	return nil
}

// SetPrefixLastNameG of the userAccount to the related item.
// Sets o.R.PrefixLastName to related.
// Adds o to related.R.UserAccounts.
// Uses the global database handle.
func (o *UserAccount) SetPrefixLastNameG(ctx context.Context, insert bool, related *PrefixLastName) error {
	return o.SetPrefixLastName(ctx, boil.GetContextDB(), insert, related)
}

// SetPrefixLastName of the userAccount to the related item.
// Sets o.R.PrefixLastName to related.
// Adds o to related.R.UserAccounts.
func (o *UserAccount) SetPrefixLastName(ctx context.Context, exec boil.ContextExecutor, insert bool, related *PrefixLastName) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"user_account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"prefix_last_name_id"}),
		strmangle.WhereClause("\"", "\"", 2, userAccountPrimaryKeyColumns),
	)
	values := []interface{}{related.PrefixLastNameID, o.UserAccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PrefixLastNameID = related.PrefixLastNameID
	if o.R == nil {
		o.R = &userAccountR{
			PrefixLastName: related,
		}
	} else {
		o.R.PrefixLastName = related
	}

	if related.R == nil {
		related.R = &prefixLastNameR{
			UserAccounts: UserAccountSlice{o},
		}
	} else {
		related.R.UserAccounts = append(related.R.UserAccounts, o)
	}

	return nil
}

// SetNameAfterLastNameG of the userAccount to the related item.
// Sets o.R.NameAfterLastName to related.
// Adds o to related.R.UserAccounts.
// Uses the global database handle.
func (o *UserAccount) SetNameAfterLastNameG(ctx context.Context, insert bool, related *NameAfterLastName) error {
	return o.SetNameAfterLastName(ctx, boil.GetContextDB(), insert, related)
}

// SetNameAfterLastName of the userAccount to the related item.
// Sets o.R.NameAfterLastName to related.
// Adds o to related.R.UserAccounts.
func (o *UserAccount) SetNameAfterLastName(ctx context.Context, exec boil.ContextExecutor, insert bool, related *NameAfterLastName) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"user_account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"name_after_last_name_id"}),
		strmangle.WhereClause("\"", "\"", 2, userAccountPrimaryKeyColumns),
	)
	values := []interface{}{related.NameAfterLastNameID, o.UserAccountID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.NameAfterLastNameID = related.NameAfterLastNameID
	if o.R == nil {
		o.R = &userAccountR{
			NameAfterLastName: related,
		}
	} else {
		o.R.NameAfterLastName = related
	}

	if related.R == nil {
		related.R = &nameAfterLastNameR{
			UserAccounts: UserAccountSlice{o},
		}
	} else {
		related.R.UserAccounts = append(related.R.UserAccounts, o)
	}

	return nil
}

// AddDimensionsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Dimensions.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddDimensionsG(ctx context.Context, insert bool, related ...*Dimension) error {
	return o.AddDimensions(ctx, boil.GetContextDB(), insert, related...)
}

// AddDimensions adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Dimensions.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddDimensions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Dimension) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"dimensions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, dimensionPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.DimensionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Dimensions: related,
		}
	} else {
		o.R.Dimensions = append(o.R.Dimensions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dimensionR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddDimensionsLinksG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.DimensionsLinks.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddDimensionsLinksG(ctx context.Context, insert bool, related ...*DimensionsLink) error {
	return o.AddDimensionsLinks(ctx, boil.GetContextDB(), insert, related...)
}

// AddDimensionsLinks adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.DimensionsLinks.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddDimensionsLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*DimensionsLink) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"dimensions_links\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, dimensionsLinkPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.DimensionsLinkID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			DimensionsLinks: related,
		}
	} else {
		o.R.DimensionsLinks = append(o.R.DimensionsLinks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &dimensionsLinkR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddDirectionsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Directions.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddDirectionsG(ctx context.Context, insert bool, related ...*Direction) error {
	return o.AddDirections(ctx, boil.GetContextDB(), insert, related...)
}

// AddDirections adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Directions.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddDirections(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Direction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"directions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, directionPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.DirectionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Directions: related,
		}
	} else {
		o.R.Directions = append(o.R.Directions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &directionR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddEmailAddressesG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.EmailAddresses.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddEmailAddressesG(ctx context.Context, insert bool, related ...*EmailAddress) error {
	return o.AddEmailAddresses(ctx, boil.GetContextDB(), insert, related...)
}

// AddEmailAddresses adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.EmailAddresses.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddEmailAddresses(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmailAddress) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"email_address\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, emailAddressPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.EmailName, rel.EmailDomainID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			EmailAddresses: related,
		}
	} else {
		o.R.EmailAddresses = append(o.R.EmailAddresses, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emailAddressR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddEmailDomainsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.EmailDomains.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddEmailDomainsG(ctx context.Context, insert bool, related ...*EmailDomain) error {
	return o.AddEmailDomains(ctx, boil.GetContextDB(), insert, related...)
}

// AddEmailDomains adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.EmailDomains.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddEmailDomains(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*EmailDomain) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"email_domain\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, emailDomainPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.EmailDomainID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			EmailDomains: related,
		}
	} else {
		o.R.EmailDomains = append(o.R.EmailDomains, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &emailDomainR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddLabelsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Labels.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddLabelsG(ctx context.Context, insert bool, related ...*Label) error {
	return o.AddLabels(ctx, boil.GetContextDB(), insert, related...)
}

// AddLabels adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Labels.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Label) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, labelPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.LabelID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Labels: related,
		}
	} else {
		o.R.Labels = append(o.R.Labels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &labelR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddLinksG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Links.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddLinksG(ctx context.Context, insert bool, related ...*Link) error {
	return o.AddLinks(ctx, boil.GetContextDB(), insert, related...)
}

// AddLinks adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Links.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Link) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"links\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, linkPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.LinkID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Links: related,
		}
	} else {
		o.R.Links = append(o.R.Links, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &linkR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddMessagesG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Messages.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddMessagesG(ctx context.Context, insert bool, related ...*Message) error {
	return o.AddMessages(ctx, boil.GetContextDB(), insert, related...)
}

// AddMessages adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Messages.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddMessages(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Message) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"messages\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, messagePrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.MessageID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Messages: related,
		}
	} else {
		o.R.Messages = append(o.R.Messages, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &messageR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddPollsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Polls.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddPollsG(ctx context.Context, insert bool, related ...*Poll) error {
	return o.AddPolls(ctx, boil.GetContextDB(), insert, related...)
}

// AddPolls adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Polls.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddPolls(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Poll) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.PollID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Polls: related,
		}
	} else {
		o.R.Polls = append(o.R.Polls, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddPollsGroupsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsGroups.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddPollsGroupsG(ctx context.Context, insert bool, related ...*PollsGroup) error {
	return o.AddPollsGroups(ctx, boil.GetContextDB(), insert, related...)
}

// AddPollsGroups adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsGroups.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddPollsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PollsGroup) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls_groups\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollsGroupPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.PollGroupID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			PollsGroups: related,
		}
	} else {
		o.R.PollsGroups = append(o.R.PollsGroups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollsGroupR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddPollsLabelsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsLabels.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddPollsLabelsG(ctx context.Context, insert bool, related ...*PollsLabel) error {
	return o.AddPollsLabels(ctx, boil.GetContextDB(), insert, related...)
}

// AddPollsLabels adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsLabels.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddPollsLabels(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PollsLabel) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls_labels\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollsLabelPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.PollLabelID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			PollsLabels: related,
		}
	} else {
		o.R.PollsLabels = append(o.R.PollsLabels, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollsLabelR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddPollsLinksG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsLinks.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddPollsLinksG(ctx context.Context, insert bool, related ...*PollsLink) error {
	return o.AddPollsLinks(ctx, boil.GetContextDB(), insert, related...)
}

// AddPollsLinks adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsLinks.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddPollsLinks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PollsLink) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls_links\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollsLinkPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.PollLinkID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			PollsLinks: related,
		}
	} else {
		o.R.PollsLinks = append(o.R.PollsLinks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollsLinkR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddPollsPollsGroupsG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsPollsGroups.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddPollsPollsGroupsG(ctx context.Context, insert bool, related ...*PollsPollsGroup) error {
	return o.AddPollsPollsGroups(ctx, boil.GetContextDB(), insert, related...)
}

// AddPollsPollsGroups adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.PollsPollsGroups.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddPollsPollsGroups(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PollsPollsGroup) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls_polls_groups\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollsPollsGroupPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.PollPollGroupID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			PollsPollsGroups: related,
		}
	} else {
		o.R.PollsPollsGroups = append(o.R.PollsPollsGroups, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollsPollsGroupR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddUserAccountEthnicitiesG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserAccountEthnicities.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddUserAccountEthnicitiesG(ctx context.Context, insert bool, related ...*UserAccountEthnicity) error {
	return o.AddUserAccountEthnicities(ctx, boil.GetContextDB(), insert, related...)
}

// AddUserAccountEthnicities adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserAccountEthnicities.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddUserAccountEthnicities(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAccountEthnicity) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_account_ethnicity\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAccountEthnicityPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.UserAccountEthnicityID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			UserAccountEthnicities: related,
		}
	} else {
		o.R.UserAccountEthnicities = append(o.R.UserAccountEthnicities, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAccountEthnicityR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddUserAccountSuffixesG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserAccountSuffixes.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddUserAccountSuffixesG(ctx context.Context, insert bool, related ...*UserAccountSuffix) error {
	return o.AddUserAccountSuffixes(ctx, boil.GetContextDB(), insert, related...)
}

// AddUserAccountSuffixes adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserAccountSuffixes.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddUserAccountSuffixes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserAccountSuffix) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_account_suffix\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, userAccountSuffixPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.UserAccountSuffixID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			UserAccountSuffixes: related,
		}
	} else {
		o.R.UserAccountSuffixes = append(o.R.UserAccountSuffixes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userAccountSuffixR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddUserPersonalInfosG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserPersonalInfos.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddUserPersonalInfosG(ctx context.Context, insert bool, related ...*UserPersonalInfo) error {
	return o.AddUserPersonalInfos(ctx, boil.GetContextDB(), insert, related...)
}

// AddUserPersonalInfos adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.UserPersonalInfos.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddUserPersonalInfos(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*UserPersonalInfo) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"user_personal_info\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, userPersonalInfoPrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.UserPersonalInfoID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			UserPersonalInfos: related,
		}
	} else {
		o.R.UserPersonalInfos = append(o.R.UserPersonalInfos, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &userPersonalInfoR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// AddVotesG adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Votes.
// Sets related.R.UserAccount appropriately.
// Uses the global database handle.
func (o *UserAccount) AddVotesG(ctx context.Context, insert bool, related ...*Vote) error {
	return o.AddVotes(ctx, boil.GetContextDB(), insert, related...)
}

// AddVotes adds the given related objects to the existing relationships
// of the user_account, optionally inserting them as new records.
// Appends related to o.R.Votes.
// Sets related.R.UserAccount appropriately.
func (o *UserAccount) AddVotes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Vote) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.UserAccountID = o.UserAccountID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"vote\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"user_account_id"}),
				strmangle.WhereClause("\"", "\"", 2, votePrimaryKeyColumns),
			)
			values := []interface{}{o.UserAccountID, rel.VoteID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.UserAccountID = o.UserAccountID
		}
	}

	if o.R == nil {
		o.R = &userAccountR{
			Votes: related,
		}
	} else {
		o.R.Votes = append(o.R.Votes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &voteR{
				UserAccount: o,
			}
		} else {
			rel.R.UserAccount = o
		}
	}
	return nil
}

// UserAccounts retrieves all the records using an executor.
func UserAccounts(mods ...qm.QueryMod) userAccountQuery {
	mods = append(mods, qm.From("\"user_account\""))
	return userAccountQuery{NewQuery(mods...)}
}

// FindUserAccountG retrieves a single record by ID.
func FindUserAccountG(ctx context.Context, userAccountID int64, selectCols ...string) (*UserAccount, error) {
	return FindUserAccount(ctx, boil.GetContextDB(), userAccountID, selectCols...)
}

// FindUserAccount retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindUserAccount(ctx context.Context, exec boil.ContextExecutor, userAccountID int64, selectCols ...string) (*UserAccount, error) {
	userAccountObj := &UserAccount{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"user_account\" where \"user_account_id\"=$1", sel,
	)

	q := queries.Raw(query, userAccountID)

	err := q.Bind(ctx, exec, userAccountObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from user_account")
	}

	return userAccountObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *UserAccount) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *UserAccount) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user_account provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userAccountColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	userAccountInsertCacheMut.RLock()
	cache, cached := userAccountInsertCache[key]
	userAccountInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			userAccountColumns,
			userAccountColumnsWithDefault,
			userAccountColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(userAccountType, userAccountMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"user_account\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"user_account\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into user_account")
	}

	if !cached {
		userAccountInsertCacheMut.Lock()
		userAccountInsertCache[key] = cache
		userAccountInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single UserAccount record using the global executor.
// See Update for more documentation.
func (o *UserAccount) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the UserAccount.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *UserAccount) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	userAccountUpdateCacheMut.RLock()
	cache, cached := userAccountUpdateCache[key]
	userAccountUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			userAccountColumns,
			userAccountPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update user_account, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"user_account\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, userAccountPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, append(wl, userAccountPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update user_account row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for user_account")
	}

	if !cached {
		userAccountUpdateCacheMut.Lock()
		userAccountUpdateCache[key] = cache
		userAccountUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q userAccountQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for user_account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for user_account")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o UserAccountSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o UserAccountSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"user_account\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, userAccountPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in userAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all userAccount")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *UserAccount) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *UserAccount) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no user_account provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(userAccountColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	userAccountUpsertCacheMut.RLock()
	cache, cached := userAccountUpsertCache[key]
	userAccountUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			userAccountColumns,
			userAccountColumnsWithDefault,
			userAccountColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			userAccountColumns,
			userAccountPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert user_account, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(userAccountPrimaryKeyColumns))
			copy(conflict, userAccountPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryCockroachDB(dialect, "\"user_account\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(userAccountType, userAccountMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(userAccountType, userAccountMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		_, _ = fmt.Fprintln(boil.DebugWriter, cache.query)
		_, _ = fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // CockcorachDB doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert user_account")
	}

	if !cached {
		userAccountUpsertCacheMut.Lock()
		userAccountUpsertCache[key] = cache
		userAccountUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single UserAccount record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *UserAccount) DeleteG(ctx context.Context) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB())
}

// Delete deletes a single UserAccount record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *UserAccount) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no UserAccount provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), userAccountPrimaryKeyMapping)
	sql := "DELETE FROM \"user_account\" WHERE \"user_account_id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from user_account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for user_account")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q userAccountQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no userAccountQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from user_account")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user_account")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o UserAccountSlice) DeleteAllG(ctx context.Context) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB())
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o UserAccountSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no UserAccount slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(userAccountBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"user_account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userAccountPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from userAccount slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for user_account")
	}

	if len(userAccountAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *UserAccount) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no UserAccount provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *UserAccount) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindUserAccount(ctx, exec, o.UserAccountID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserAccountSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty UserAccountSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *UserAccountSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := UserAccountSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), userAccountPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"user_account\".* FROM \"user_account\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, userAccountPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in UserAccountSlice")
	}

	*o = slice

	return nil
}

// UserAccountExistsG checks if the UserAccount row exists.
func UserAccountExistsG(ctx context.Context, userAccountID int64) (bool, error) {
	return UserAccountExists(ctx, boil.GetContextDB(), userAccountID)
}

// UserAccountExists checks if the UserAccount row exists.
func UserAccountExists(ctx context.Context, exec boil.ContextExecutor, userAccountID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"user_account\" where \"user_account_id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, userAccountID)
	}

	row := exec.QueryRowContext(ctx, sql, userAccountID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if user_account exists")
	}

	return exists, nil
}
