// Code generated by SQLBoiler (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/pkg/errors"
	"github.com/volatiletech/sqlboiler/boil"
	"github.com/volatiletech/sqlboiler/queries"
	"github.com/volatiletech/sqlboiler/queries/qm"
	"github.com/volatiletech/sqlboiler/strmangle"
)

// FactorPosition is an object representing the database table.
type FactorPosition struct {
	FactorPositionID int64     `boil:"factor_position_id" json:"factor_position_id" toml:"factor_position_id" yaml:"factor_position_id"`
	FactorID         int64     `boil:"factor_id" json:"factor_id" toml:"factor_id" yaml:"factor_id"`
	PositionID       int64     `boil:"position_id" json:"position_id" toml:"position_id" yaml:"position_id"`
	UserAccountID    int64     `boil:"user_account_id" json:"user_account_id" toml:"user_account_id" yaml:"user_account_id"`
	CreatedAt        time.Time `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`

	R *factorPositionR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L factorPositionL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var FactorPositionColumns = struct {
	FactorPositionID string
	FactorID         string
	PositionID       string
	UserAccountID    string
	CreatedAt        string
}{
	FactorPositionID: "factor_position_id",
	FactorID:         "factor_id",
	PositionID:       "position_id",
	UserAccountID:    "user_account_id",
	CreatedAt:        "created_at",
}

// FactorPositionRels is where relationship names are stored.
var FactorPositionRels = struct {
	Position              string
	Factor                string
	PollsFactorsPositions string
}{
	Position:              "Position",
	Factor:                "Factor",
	PollsFactorsPositions: "PollsFactorsPositions",
}

// factorPositionR is where relationships are stored.
type factorPositionR struct {
	Position              *Position
	Factor                *Factor
	PollsFactorsPositions PollsFactorsPositionSlice
}

// NewStruct creates a new relationship struct
func (*factorPositionR) NewStruct() *factorPositionR {
	return &factorPositionR{}
}

// factorPositionL is where Load methods for each relationship are stored.
type factorPositionL struct{}

var (
	factorPositionColumns               = []string{"factor_position_id", "factor_id", "position_id", "user_account_id", "created_at"}
	factorPositionColumnsWithoutDefault = []string{"factor_position_id", "factor_id", "position_id", "user_account_id", "created_at"}
	factorPositionColumnsWithDefault    = []string{}
	factorPositionPrimaryKeyColumns     = []string{"factor_position_id"}
)

type (
	// FactorPositionSlice is an alias for a slice of pointers to FactorPosition.
	// This should generally be used opposed to []FactorPosition.
	FactorPositionSlice []*FactorPosition
	// FactorPositionHook is the signature for custom FactorPosition hook methods
	FactorPositionHook func(context.Context, boil.ContextExecutor, *FactorPosition) error

	factorPositionQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	factorPositionType                 = reflect.TypeOf(&FactorPosition{})
	factorPositionMapping              = queries.MakeStructMapping(factorPositionType)
	factorPositionPrimaryKeyMapping, _ = queries.BindMapping(factorPositionType, factorPositionMapping, factorPositionPrimaryKeyColumns)
	factorPositionInsertCacheMut       sync.RWMutex
	factorPositionInsertCache          = make(map[string]insertCache)
	factorPositionUpdateCacheMut       sync.RWMutex
	factorPositionUpdateCache          = make(map[string]updateCache)
	factorPositionUpsertCacheMut       sync.RWMutex
	factorPositionUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
)

var factorPositionBeforeInsertHooks []FactorPositionHook
var factorPositionBeforeUpdateHooks []FactorPositionHook
var factorPositionBeforeDeleteHooks []FactorPositionHook
var factorPositionBeforeUpsertHooks []FactorPositionHook

var factorPositionAfterInsertHooks []FactorPositionHook
var factorPositionAfterSelectHooks []FactorPositionHook
var factorPositionAfterUpdateHooks []FactorPositionHook
var factorPositionAfterDeleteHooks []FactorPositionHook
var factorPositionAfterUpsertHooks []FactorPositionHook

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *FactorPosition) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *FactorPosition) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *FactorPosition) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *FactorPosition) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *FactorPosition) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterSelectHooks executes all "after Select" hooks.
func (o *FactorPosition) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *FactorPosition) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *FactorPosition) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *FactorPosition) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	for _, hook := range factorPositionAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddFactorPositionHook registers your hook function for all future operations.
func AddFactorPositionHook(hookPoint boil.HookPoint, factorPositionHook FactorPositionHook) {
	switch hookPoint {
	case boil.BeforeInsertHook:
		factorPositionBeforeInsertHooks = append(factorPositionBeforeInsertHooks, factorPositionHook)
	case boil.BeforeUpdateHook:
		factorPositionBeforeUpdateHooks = append(factorPositionBeforeUpdateHooks, factorPositionHook)
	case boil.BeforeDeleteHook:
		factorPositionBeforeDeleteHooks = append(factorPositionBeforeDeleteHooks, factorPositionHook)
	case boil.BeforeUpsertHook:
		factorPositionBeforeUpsertHooks = append(factorPositionBeforeUpsertHooks, factorPositionHook)
	case boil.AfterInsertHook:
		factorPositionAfterInsertHooks = append(factorPositionAfterInsertHooks, factorPositionHook)
	case boil.AfterSelectHook:
		factorPositionAfterSelectHooks = append(factorPositionAfterSelectHooks, factorPositionHook)
	case boil.AfterUpdateHook:
		factorPositionAfterUpdateHooks = append(factorPositionAfterUpdateHooks, factorPositionHook)
	case boil.AfterDeleteHook:
		factorPositionAfterDeleteHooks = append(factorPositionAfterDeleteHooks, factorPositionHook)
	case boil.AfterUpsertHook:
		factorPositionAfterUpsertHooks = append(factorPositionAfterUpsertHooks, factorPositionHook)
	}
}

// One returns a single factorPosition record from the query.
func (q factorPositionQuery) One(ctx context.Context, exec boil.ContextExecutor) (*FactorPosition, error) {
	o := &FactorPosition{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for factor_positions")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// All returns all FactorPosition records from the query.
func (q factorPositionQuery) All(ctx context.Context, exec boil.ContextExecutor) (FactorPositionSlice, error) {
	var o []*FactorPosition

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to FactorPosition slice")
	}

	if len(factorPositionAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// Count returns the count of all FactorPosition records in the query.
func (q factorPositionQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count factor_positions rows")
	}

	return count, nil
}

// Exists checks if the row exists in the table.
func (q factorPositionQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if factor_positions exists")
	}

	return count > 0, nil
}

// Position pointed to by the foreign key.
func (o *FactorPosition) Position(mods ...qm.QueryMod) positionQuery {
	queryMods := []qm.QueryMod{
		qm.Where("position_id=?", o.PositionID),
	}

	queryMods = append(queryMods, mods...)

	query := Positions(queryMods...)
	queries.SetFrom(query.Query, "\"positions\"")

	return query
}

// Factor pointed to by the foreign key.
func (o *FactorPosition) Factor(mods ...qm.QueryMod) factorQuery {
	queryMods := []qm.QueryMod{
		qm.Where("factor_id=?", o.FactorID),
	}

	queryMods = append(queryMods, mods...)

	query := Factors(queryMods...)
	queries.SetFrom(query.Query, "\"factors\"")

	return query
}

// PollsFactorsPositions retrieves all the polls_factors_position's PollsFactorsPositions with an executor.
func (o *FactorPosition) PollsFactorsPositions(mods ...qm.QueryMod) pollsFactorsPositionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"polls_factors_positions\".\"factor_position_id\"=?", o.FactorPositionID),
	)

	query := PollsFactorsPositions(queryMods...)
	queries.SetFrom(query.Query, "\"polls_factors_positions\"")

	if len(queries.GetSelect(query.Query)) == 0 {
		queries.SetSelect(query.Query, []string{"\"polls_factors_positions\".*"})
	}

	return query
}

// LoadPosition allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (factorPositionL) LoadPosition(ctx context.Context, e boil.ContextExecutor, singular bool, maybeFactorPosition interface{}, mods queries.Applicator) error {
	var slice []*FactorPosition
	var object *FactorPosition

	if singular {
		object = maybeFactorPosition.(*FactorPosition)
	} else {
		slice = *maybeFactorPosition.(*[]*FactorPosition)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factorPositionR{}
		}
		args = append(args, object.PositionID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factorPositionR{}
			}

			for _, a := range args {
				if a == obj.PositionID {
					continue Outer
				}
			}

			args = append(args, obj.PositionID)
		}
	}

	query := NewQuery(qm.From(`positions`), qm.WhereIn(`position_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Position")
	}

	var resultSlice []*Position
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Position")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for positions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for positions")
	}

	if len(factorPositionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Position = foreign
		if foreign.R == nil {
			foreign.R = &positionR{}
		}
		foreign.R.FactorPositions = append(foreign.R.FactorPositions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.PositionID == foreign.PositionID {
				local.R.Position = foreign
				if foreign.R == nil {
					foreign.R = &positionR{}
				}
				foreign.R.FactorPositions = append(foreign.R.FactorPositions, local)
				break
			}
		}
	}

	return nil
}

// LoadFactor allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (factorPositionL) LoadFactor(ctx context.Context, e boil.ContextExecutor, singular bool, maybeFactorPosition interface{}, mods queries.Applicator) error {
	var slice []*FactorPosition
	var object *FactorPosition

	if singular {
		object = maybeFactorPosition.(*FactorPosition)
	} else {
		slice = *maybeFactorPosition.(*[]*FactorPosition)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factorPositionR{}
		}
		args = append(args, object.FactorID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factorPositionR{}
			}

			for _, a := range args {
				if a == obj.FactorID {
					continue Outer
				}
			}

			args = append(args, obj.FactorID)
		}
	}

	query := NewQuery(qm.From(`factors`), qm.WhereIn(`factor_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Factor")
	}

	var resultSlice []*Factor
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Factor")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for factors")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for factors")
	}

	if len(factorPositionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.Factor = foreign
		if foreign.R == nil {
			foreign.R = &factorR{}
		}
		foreign.R.FactorPositions = append(foreign.R.FactorPositions, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.FactorID == foreign.FactorID {
				local.R.Factor = foreign
				if foreign.R == nil {
					foreign.R = &factorR{}
				}
				foreign.R.FactorPositions = append(foreign.R.FactorPositions, local)
				break
			}
		}
	}

	return nil
}

// LoadPollsFactorsPositions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (factorPositionL) LoadPollsFactorsPositions(ctx context.Context, e boil.ContextExecutor, singular bool, maybeFactorPosition interface{}, mods queries.Applicator) error {
	var slice []*FactorPosition
	var object *FactorPosition

	if singular {
		object = maybeFactorPosition.(*FactorPosition)
	} else {
		slice = *maybeFactorPosition.(*[]*FactorPosition)
	}

	args := make([]interface{}, 0, 1)
	if singular {
		if object.R == nil {
			object.R = &factorPositionR{}
		}
		args = append(args, object.FactorPositionID)
	} else {
	Outer:
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &factorPositionR{}
			}

			for _, a := range args {
				if a == obj.FactorPositionID {
					continue Outer
				}
			}

			args = append(args, obj.FactorPositionID)
		}
	}

	query := NewQuery(qm.From(`polls_factors_positions`), qm.WhereIn(`factor_position_id in ?`, args...))
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load polls_factors_positions")
	}

	var resultSlice []*PollsFactorsPosition
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice polls_factors_positions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on polls_factors_positions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for polls_factors_positions")
	}

	if len(pollsFactorsPositionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PollsFactorsPositions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &pollsFactorsPositionR{}
			}
			foreign.R.FactorPosition = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.FactorPositionID == foreign.FactorPositionID {
				local.R.PollsFactorsPositions = append(local.R.PollsFactorsPositions, foreign)
				if foreign.R == nil {
					foreign.R = &pollsFactorsPositionR{}
				}
				foreign.R.FactorPosition = local
				break
			}
		}
	}

	return nil
}

// SetPosition of the factorPosition to the related item.
// Sets o.R.Position to related.
// Adds o to related.R.FactorPositions.
func (o *FactorPosition) SetPosition(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Position) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"factor_positions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"position_id"}),
		strmangle.WhereClause("\"", "\"", 2, factorPositionPrimaryKeyColumns),
	)
	values := []interface{}{related.PositionID, o.FactorPositionID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.PositionID = related.PositionID
	if o.R == nil {
		o.R = &factorPositionR{
			Position: related,
		}
	} else {
		o.R.Position = related
	}

	if related.R == nil {
		related.R = &positionR{
			FactorPositions: FactorPositionSlice{o},
		}
	} else {
		related.R.FactorPositions = append(related.R.FactorPositions, o)
	}

	return nil
}

// SetFactor of the factorPosition to the related item.
// Sets o.R.Factor to related.
// Adds o to related.R.FactorPositions.
func (o *FactorPosition) SetFactor(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Factor) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"factor_positions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"factor_id"}),
		strmangle.WhereClause("\"", "\"", 2, factorPositionPrimaryKeyColumns),
	)
	values := []interface{}{related.FactorID, o.FactorPositionID}

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, updateQuery)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.FactorID = related.FactorID
	if o.R == nil {
		o.R = &factorPositionR{
			Factor: related,
		}
	} else {
		o.R.Factor = related
	}

	if related.R == nil {
		related.R = &factorR{
			FactorPositions: FactorPositionSlice{o},
		}
	} else {
		related.R.FactorPositions = append(related.R.FactorPositions, o)
	}

	return nil
}

// AddPollsFactorsPositions adds the given related objects to the existing relationships
// of the factor_position, optionally inserting them as new records.
// Appends related to o.R.PollsFactorsPositions.
// Sets related.R.FactorPosition appropriately.
func (o *FactorPosition) AddPollsFactorsPositions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PollsFactorsPosition) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.FactorPositionID = o.FactorPositionID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"polls_factors_positions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"factor_position_id"}),
				strmangle.WhereClause("\"", "\"", 2, pollsFactorsPositionPrimaryKeyColumns),
			)
			values := []interface{}{o.FactorPositionID, rel.PollFactorPositionID}

			if boil.DebugMode {
				fmt.Fprintln(boil.DebugWriter, updateQuery)
				fmt.Fprintln(boil.DebugWriter, values)
			}

			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.FactorPositionID = o.FactorPositionID
		}
	}

	if o.R == nil {
		o.R = &factorPositionR{
			PollsFactorsPositions: related,
		}
	} else {
		o.R.PollsFactorsPositions = append(o.R.PollsFactorsPositions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &pollsFactorsPositionR{
				FactorPosition: o,
			}
		} else {
			rel.R.FactorPosition = o
		}
	}
	return nil
}

// FactorPositions retrieves all the records using an executor.
func FactorPositions(mods ...qm.QueryMod) factorPositionQuery {
	mods = append(mods, qm.From("\"factor_positions\""))
	return factorPositionQuery{NewQuery(mods...)}
}

// FindFactorPosition retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindFactorPosition(ctx context.Context, exec boil.ContextExecutor, factorPositionID int64, selectCols ...string) (*FactorPosition, error) {
	factorPositionObj := &FactorPosition{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"factor_positions\" where \"factor_position_id\"=$1", sel,
	)

	q := queries.Raw(query, factorPositionID)

	err := q.Bind(ctx, exec, factorPositionObj)
	if err != nil {
		if errors.Cause(err) == sql.ErrNoRows {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from factor_positions")
	}

	return factorPositionObj, nil
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *FactorPosition) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no factor_positions provided for insertion")
	}

	var err error
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(factorPositionColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	factorPositionInsertCacheMut.RLock()
	cache, cached := factorPositionInsertCache[key]
	factorPositionInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			factorPositionColumns,
			factorPositionColumnsWithDefault,
			factorPositionColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(factorPositionType, factorPositionMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(factorPositionType, factorPositionMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"factor_positions\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"factor_positions\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into factor_positions")
	}

	if !cached {
		factorPositionInsertCacheMut.Lock()
		factorPositionInsertCache[key] = cache
		factorPositionInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// Update uses an executor to update the FactorPosition.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *FactorPosition) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	factorPositionUpdateCacheMut.RLock()
	cache, cached := factorPositionUpdateCache[key]
	factorPositionUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			factorPositionColumns,
			factorPositionPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update factor_positions, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"factor_positions\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, factorPositionPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(factorPositionType, factorPositionMapping, append(wl, factorPositionPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, cache.query)
		fmt.Fprintln(boil.DebugWriter, values)
	}

	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update factor_positions row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for factor_positions")
	}

	if !cached {
		factorPositionUpdateCacheMut.Lock()
		factorPositionUpdateCache[key] = cache
		factorPositionUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAll updates all rows with the specified column values.
func (q factorPositionQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for factor_positions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for factor_positions")
	}

	return rowsAff, nil
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o FactorPositionSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factorPositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"factor_positions\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, factorPositionPrimaryKeyColumns, len(o)))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in factorPosition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all factorPosition")
	}
	return rowsAff, nil
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *FactorPosition) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns) error {
	if o == nil {
		return errors.New("models: no factor_positions provided for upsert")
	}
	currTime := time.Now().In(boil.GetLocation())

	if o.CreatedAt.IsZero() {
		o.CreatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(factorPositionColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	factorPositionUpsertCacheMut.RLock()
	cache, cached := factorPositionUpsertCache[key]
	factorPositionUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, ret := insertColumns.InsertColumnSet(
			factorPositionColumns,
			factorPositionColumnsWithDefault,
			factorPositionColumnsWithoutDefault,
			nzDefaults,
		)
		update := updateColumns.UpdateColumnSet(
			factorPositionColumns,
			factorPositionPrimaryKeyColumns,
		)

		if len(update) == 0 {
			return errors.New("models: unable to upsert factor_positions, could not build update column list")
		}

		conflict := conflictColumns
		if len(conflict) == 0 {
			conflict = make([]string, len(factorPositionPrimaryKeyColumns))
			copy(conflict, factorPositionPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryCockroachDB(dialect, "\"factor_positions\"", updateOnConflict, ret, update, conflict, insert)

		cache.valueMapping, err = queries.BindMapping(factorPositionType, factorPositionMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(factorPositionType, factorPositionMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.DebugMode {
		_, _ = fmt.Fprintln(boil.DebugWriter, cache.query)
		_, _ = fmt.Fprintln(boil.DebugWriter, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if err == sql.ErrNoRows {
			err = nil // CockcorachDB doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert factor_positions")
	}

	if !cached {
		factorPositionUpsertCacheMut.Lock()
		factorPositionUpsertCache[key] = cache
		factorPositionUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// Delete deletes a single FactorPosition record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *FactorPosition) Delete(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no FactorPosition provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	args := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), factorPositionPrimaryKeyMapping)
	sql := "DELETE FROM \"factor_positions\" WHERE \"factor_position_id\"=$1"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args...)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from factor_positions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for factor_positions")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

// DeleteAll deletes all matching rows.
func (q factorPositionQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no factorPositionQuery provided for delete all")
	}

	queries.SetDelete(q.Query)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from factor_positions")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for factor_positions")
	}

	return rowsAff, nil
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o FactorPositionSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no FactorPosition slice provided for delete all")
	}

	if len(o) == 0 {
		return 0, nil
	}

	if len(factorPositionBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var args []interface{}
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factorPositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "DELETE FROM \"factor_positions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, factorPositionPrimaryKeyColumns, len(o))

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, args)
	}

	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from factorPosition slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for factor_positions")
	}

	if len(factorPositionAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *FactorPosition) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindFactorPosition(ctx, exec, o.FactorPositionID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *FactorPositionSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := FactorPositionSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), factorPositionPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"factor_positions\".* FROM \"factor_positions\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, factorPositionPrimaryKeyColumns, len(*o))

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in FactorPositionSlice")
	}

	*o = slice

	return nil
}

// FactorPositionExists checks if the FactorPosition row exists.
func FactorPositionExists(ctx context.Context, exec boil.ContextExecutor, factorPositionID int64) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"factor_positions\" where \"factor_position_id\"=$1 limit 1)"

	if boil.DebugMode {
		fmt.Fprintln(boil.DebugWriter, sql)
		fmt.Fprintln(boil.DebugWriter, factorPositionID)
	}

	row := exec.QueryRowContext(ctx, sql, factorPositionID)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if factor_positions exists")
	}

	return exists, nil
}
